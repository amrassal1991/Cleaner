#Requires -RunAsAdministrator

param(
    [switch]$Headless,
    [switch]$Automated,
    [ValidateRange(1,8)][int]$Phase # Phase 8 added for "Test All Modules"
)

#region --- Configuration and Setup ---

# ANSI color codes for console output
$COLOR_RED = "`e[31m"
$COLOR_GREEN = "`e[32m"
$COLOR_YELLOW = "`e[33m"
$COLOR_CYAN = "`e[36m"
$COLOR_RESET = "`e[0m"

# Initialize script-wide variables
$scriptName = $MyInvocation.MyCommand.Name
$config = $null

# Initialize logDir early with a fallback path for initial logging.
# This ensures that Write-Log can function even before Config.json is loaded and BaseDir is resolved.
$tempLogFilePath = Join-Path $env:TEMP "$($scriptName)_InitialLog.log"
$script:logDir = Split-Path $tempLogFilePath # The directory for the initial temp log file
$initialLogFileUsed = $false # Flag to track if the initial temporary log file was used

$baseDir = $null # The base directory for logs, reports, and backups, derived from Config.json
$reportDir = $null # Directory for reports
$backupDir = $null # Directory for backups
$stateFile = $null # Path to the state tracking file (e.g., for completed phases)
$lockFile = "$env:TEMP\$($scriptName).lock" # A lock file to prevent multiple instances from running
$completedPhases = @() # Array to track phases that have been successfully completed
$phaseReports = @{} # Hashtable to store reports generated by each phase
$startTime = Get-Date # Records the script start time for calculating duration
$headless = $Headless.IsPresent # True if -Headless switch was provided on the command line
$automated = $Automated.IsPresent # True if -Automated switch was provided on the command line
# Determines the specific phase to run if the -Phase parameter is used
$selectedPhase = if ($PSBoundParameters.ContainsKey('Phase')) { "Phase$Phase" } else { $null }

#endregion

#region --- Helper Functions ---

# Function to write messages to a log file and optionally to the console.
# It includes robust error handling for log file operations.
function Write-Log {
    param(
        [Parameter(Mandatory=$true)][string]$Message, # The log message content.
        [string]$Level = "INFO", # The severity level of the log (e.g., INFO, WARNING, ERROR, FATAL, DEBUG).
        [string]$Phase = "Main" # The specific phase or module the log message originates from.
    )
    
    # Determine the effective log directory for the current log entry.
    # It prioritizes the resolved $script:logDir (after config load),
    # otherwise, it falls back to a temporary directory for early logs.
    $currentLogDir = if ($script:logDir -and (Test-Path -Path $script:logDir -PathType Container -ErrorAction SilentlyContinue)) {
        $script:logDir
    } else {
        $initialLogFileUsed = $true # Mark that the initial temporary log file is being used.
        Join-Path $env:TEMP "" # Returns the TEMP directory path.
    }

    # Ensure the log directory path does not end with a backslash to prevent issues with path joining.
    $currentLogDir = $currentLogDir -replace '\\$', '' 
    $logFile = "$currentLogDir\$Phase.log" # Constructs the full path to the log file for this specific phase.
    $logMessage = "$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss') [$Level]: $Message" # Formats the log message with timestamp and level.
    
    try {
        # Check if the current log directory exists; create it if it doesn't.
        if (!(Test-Path $currentLogDir)) {
            New-Item -ItemType Directory -Path $currentLogDir -ErrorAction Stop | Out-Null # -ErrorAction Stop ensures fatal error if directory creation fails.
        }
        # Appends the formatted log message to the specified log file.
        Add-Content -Path $logFile -Value $logMessage -ErrorAction SilentlyContinue # -ErrorAction SilentlyContinue prevents script from stopping if writing to log fails.
    }
    catch {
        # If logging to file fails, write an error message to the console.
        Write-Host "$COLOR_RED[ERROR - Logging]: Failed to write to log file '$logFile'. Error: $($_.Exception.Message)$COLOR_RESET"
    }
}

# Function to check if the current PowerShell session is running with Administrator privileges.
function Test-IsAdministrator {
    # Gets the current user's Windows identity and checks if they belong to the Administrator role.
    ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
}

# Function to interact with the Ollama language model via its command-line interface.
function Invoke-Ollama {
    param(
        [Parameter(Mandatory=$true)][string]$Prompt # The text prompt to send to the Ollama model (e.g., "Summarize this...").
    )
    
    Write-Log "Attempting to communicate with Ollama for prompt: '$Prompt'" -Phase "Ollama"
    try {
        # Check if the 'ollama' command-line tool is available in the system's PATH.
        if (-not (Get-Command ollama -ErrorAction SilentlyContinue)) {
            throw "Ollama command not found. Please ensure Ollama is installed and added to your system's PATH."
        }
        
        # Execute the ollama command directly using the `&` call operator for external executables.
        # This is more robust for external commands than Invoke-Expression.
        # The prompt is properly quoted to be passed as a single argument to ollama.
        # 2>&1 redirects standard error to standard output, so all output (success or error messages from ollama) is captured.
        $ollamaCommand = "ollama"
        $ollamaArgs = "run llama3 `"$Prompt`"" # The `"` ensures the prompt is passed as one argument.
        
        $response = & $ollamaCommand $ollamaArgs 2>&1

        # Check the exit code of the last native command executed ($LASTEXITCODE).
        # A non-zero exit code typically indicates an error from the external program.
        if ($LASTEXITCODE -ne 0) {
            Write-Log "Ollama command exited with code $LASTEXITCODE. Output: $response" -Level "ERROR" -Phase "Ollama"
            throw "Ollama command failed. Output: $response"
        }
        
        Write-Log "Ollama response: $response" -Phase "Ollama"
        return $response # Return the successful response from Ollama.
    }
    catch {
        # Catch any errors that occur during Ollama communication and log them.
        Write-Log "Error communicating with Ollama: $($_.Exception.Message)" -Level "ERROR" -Phase "Ollama"
        # Also print a user-friendly error message to the console.
        Write-Host "$COLOR_RED[ERROR]: Ollama communication failed. $($_.Exception.Message)$COLOR_RESET"
        return $null # Return null to indicate that the operation failed.
    }
}

#endregion

#region --- Integrated Module Functions (Formerly separate .ps1 files) ---
# These functions represent the logic that would typically be in your D:\cleanerps\Modules folder.
# They are now included directly in this script for easier management and orchestration.

function Invoke-AnalyzeFiles {
    param(
        [Parameter(Mandatory=$true)]$Config, # Pass the configuration object
        [Parameter(Mandatory=$true)]$BaseDir # Pass the resolved base directory
    )
    Write-Log "Starting Analyze-Files module." -Phase "AnalyzeFiles"
    Write-Host "$COLOR_YELLOW[Module]: Analyzing files in '$($Config.Paths[0])'...$COLOR_RESET"
    # --- Your actual Analyze-Files.ps1 logic would go here ---
    # Example: Scan directories, generate reports, etc.
    Start-Sleep -Milliseconds 500 # Simulate work
    Write-Log "Analyze-Files module completed." -Phase "AnalyzeFiles"
    return $true # Indicate success
}

function Invoke-CleanResiduals {
    param(
        [Parameter(Mandatory=$true)]$Config,
        [Parameter(Mandatory=$true)]$BaseDir
    )
    Write-Log "Starting Clean-Residuals module." -Phase "CleanResiduals"
    Write-Host "$COLOR_YELLOW[Module]: Cleaning residual files...$COLOR_RESET"
    # --- Your actual Clean-Residuals.ps1 logic would go here ---
    Start-Sleep -Milliseconds 500 # Simulate work
    Write-Log "Clean-Residuals module completed." -Phase "CleanResiduals"
    return $true
}

function Invoke-OrganizeDownloads {
    param(
        [Parameter(Mandatory=$true)]$Config,
        [Parameter(Mandatory=$true)]$BaseDir
    )
    Write-Log "Starting Organize-Downloads module." -Phase "OrganizeDownloads"
    Write-Host "$COLOR_YELLOW[Module]: Organizing downloads...$COLOR_RESET"
    # --- Your actual Organize-Downloads.ps1 logic would go here ---
    # Example: Move files from downloads to DestFolders
    Start-Sleep -Milliseconds 500 # Simulate work
    Write-Log "Organize-Downloads module completed." -Phase "OrganizeDownloads"
    return $true
}

function Invoke-OrganizeFiles {
    param(
        [Parameter(Mandatory=$true)]$Config,
        [Parameter(Mandatory=$true)]$BaseDir
    )
    Write-Log "Starting Organize-Files module." -Phase "OrganizeFiles"
    Write-Host "$COLOR_YELLOW[Module]: Organizing general files...$COLOR_RESET"
    # --- Your actual Organize-Files.ps1 logic would go here ---
    Start-Sleep -Milliseconds 500 # Simulate work
    Write-Log "Organize-Files module completed." -Phase "OrganizeFiles"
    return $true
}

function Invoke-ScanResiduals {
    param(
        [Parameter(Mandatory=$true)]$Config,
        [Parameter(Mandatory=$true)]$BaseDir
    )
    Write-Log "Starting Scan-Residuals module." -Phase "ScanResiduals"
    Write-Host "$COLOR_YELLOW[Module]: Scanning for residual files...$COLOR_RESET"
    # --- Your actual Scan-Residuals.ps1 logic would go here ---
    Start-Sleep -Milliseconds 500 # Simulate work
    Write-Log "Scan-Residuals module completed." -Phase "ScanResiduals"
    return $true
}

function Invoke-TestEnvironment {
    param(
        [Parameter(Mandatory=$true)]$Config,
        [Parameter(Mandatory=$true)]$BaseDir
    )
    Write-Log "Starting Test-Environment module." -Phase "TestEnvironment"
    Write-Host "$COLOR_YELLOW[Module]: Testing environment setup...$COLOR_RESET"
    # --- Your actual Test-Environment.ps1 logic would go here ---
    Start-Sleep -Milliseconds 500 # Simulate work
    Write-Log "Test-Environment module completed." -Phase "TestEnvironment"
    return $true
}

function Invoke-VerifySpace {
    param(
        [Parameter(Mandatory=$true)]$Config,
        [Parameter(Mandatory=$true)]$BaseDir
    )
    Write-Log "Starting Verify-Space module." -Phase "VerifySpace"
    Write-Host "$COLOR_YELLOW[Module]: Verifying disk space...$COLOR_RESET"
    # --- Your actual Verify-Space.ps1 logic would go here ---
    Start-Sleep -Milliseconds 500 # Simulate work
    Write-Log "Verify-Space module completed." -Phase "VerifySpace"
    return $true
}

# New orchestration function to call all core modules
function Invoke-AllCoreModules {
    param(
        [Parameter(Mandatory=$true)]$Config,
        [Parameter(Mandatory=$true)]$BaseDir
    )
    Write-Log "Starting orchestration of all core modules." -Phase "Orchestration"
    Write-Host "$COLOR_CYAN--- Starting Core Modules Execution ---$COLOR_RESET"

    $modulesToRun = @(
        { Invoke-TestEnvironment -Config $Config -BaseDir $BaseDir },
        { Invoke-VerifySpace -Config $Config -BaseDir $BaseDir },
        { Invoke-ScanResiduals -Config $Config -BaseDir $BaseDir },
        { Invoke-AnalyzeFiles -Config $Config -BaseDir $BaseDir },
        { Invoke-OrganizeDownloads -Config $Config -BaseDir $BaseDir },
        { Invoke-OrganizeFiles -Config $Config -BaseDir $BaseDir },
        { Invoke-CleanResiduals -Config $Config -BaseDir $BaseDir }
    )

    foreach ($moduleScriptBlock in $modulesToRun) {
        # Extract module name from script block for logging/display
        $moduleName = ($moduleScriptBlock.ToString() -replace '\{ Invoke-|\s+-Config \$Config -BaseDir \$BaseDir \}','').Trim()
        try {
            Write-Host "$COLOR_CYAN[Orchestration]: Executing $moduleName...$COLOR_RESET"
            Write-Log "Executing module: $moduleName" -Phase "Orchestration"
            & $moduleScriptBlock # Execute the script block
            $script:completedPhases += $moduleName # Add to completed list upon success
            Write-Log "Module '$moduleName' completed successfully." -Phase "Orchestration"
        }
        catch {
            Write-Log "Module '$moduleName' failed: $($_.Exception.Message)" -Level "ERROR" -Phase "Orchestration"
            Write-Host "$COLOR_RED[Orchestration ERROR]: Module '$moduleName' failed: $($_.Exception.Message)$COLOR_RESET"
            # Decide if you want to stop on first error or continue.
            # For testing, you might want to continue, for production, you might exit.
            # For now, we'll continue logging errors.
        }
    }

    Write-Log "Orchestration of all core modules completed." -Phase "Orchestration"
    Write-Host "$COLOR_CYAN--- All Core Modules Executed ---$COLOR_RESET"
}

#endregion

#region --- Script Main Execution ---

# This section contains the primary logic of the script. It executes sequentially from top to bottom.

Write-Host "$COLOR_CYANStarting $scriptName script...$COLOR_RESET"
Write-Log "Script started." # This initial log entry will go to the temporary log file for now.

# Step 1: Verify Administrator privileges.
if (-not (Test-IsAdministrator)) {
    Write-Log "Script requires Administrator privileges. Exiting." -Level "FATAL"
    Write-Host "$COLOR_RED[FATAL]: This script must be run as Administrator. Please right-click and 'Run as administrator'.$COLOR_RESET"
    exit 1 # Exit the script with an error code.
}

# Step 2: Implement a lock file mechanism to prevent multiple instances of the script from running concurrently.
try {
    # Check if a lock file already exists.
    if (Test-Path $lockFile) {
        $lockFileContent = Get-Content $lockFile -ErrorAction SilentlyContinue
        if ($lockFileContent) {
            Write-Log "Lock file '$lockFile' found. Another instance might be running or previous run crashed. Content: $lockFileContent" -Level "WARNING"
            Write-Host "$COLOR_YELLOW[WARNING]: Lock file found. Another instance may be running or a previous run crashed.$COLOR_RESET"
            # Optional: Add logic here to prompt the user to continue or to check for an active process associated with the lock file.
        } else {
            Write-Log "Empty lock file '$lockFile' found. Attempting to create new one." -Level "INFO"
        }
    }
    
    # Create the lock file, writing the current process ID and timestamp to it.
    "$(Get-Process -Id $PID). $(Get-Date)" | Set-Content $lockFile -ErrorAction Stop
    Write-Log "Lock file '$lockFile' created."

}
catch {
    # Handle any errors that occur during the lock file creation.
    Write-Log "Failed to create lock file '$lockFile'. $($_.Exception.Message)" -Level "FATAL"
    Write-Host "$COLOR_RED[FATAL]: Could not create lock file '$lockFile'. Another instance might be running or permissions issue. $($_.Exception.Message)$COLOR_RESET"
    exit 1 # Exit the script with an error code.
}

# Step 3: Load and validate configuration from Config.json, and set up directories.
try {
    # Construct the full path to Config.json, assuming it's in the same directory as the script.
    $configPath = Join-Path (Split-Path $MyInvocation.MyCommand.Definition) "Config.json"
    if (-not (Test-Path $configPath)) {
        throw "Config.json not found at '$configPath'. Please ensure it exists."
    }
    # Read the JSON content from the file and convert it to a PowerShell object.
    $config = Get-Content $configPath | ConvertFrom-Json -ErrorAction Stop
    Write-Log "Config.json loaded successfully."

    # Validate that the essential 'BaseDir' property is defined in Config.json.
    if (-not $config.BaseDir) {
        throw "BaseDir is not defined in Config.json. Please ensure your Config.json contains a 'BaseDir' property."
    }

    # Resolve the BaseDir path from the string in Config.json.
    # This now handles both $env:VAR and $((...)) subexpressions robustly.
    try {
        $rawBaseDirString = $config.BaseDir # Get the string value for BaseDir directly from JSON.
        
        $processedBaseDir = $rawBaseDirString

        # 1. Evaluate and replace PowerShell subexpressions (e.g., "$((Get-Date -Format '...'))") FIRST
        # This is important because the output might then contain $env: variables.
        # Regex to find $((...)) - non-greedy match inside
        $subExpressionRegex = '\$\(\((.*?)\)\)'
        $subExpressionMatches = [regex]::Matches($processedBaseDir, $subExpressionRegex)

        # Loop through matches and evaluate each subexpression
        foreach ($match in $subExpressionMatches) {
            $expression = $match.Groups[1].Value # The content inside the $((...))
            try {
                # Invoke-Expression is used for evaluating the PowerShell code inside the subexpression
                $evaluatedValue = Invoke-Expression $expression 
                # Replace the original subexpression string with its evaluated value
                $processedBaseDir = $processedBaseDir.Replace($match.Value, "$evaluatedValue")
            } catch {
                Write-Log "Failed to evaluate sub-expression '$expression' in BaseDir: $($_.Exception.Message)" -Level "ERROR"
                throw "Failed to resolve dynamic BaseDir part from '$expression'."
            }
        }

        # 2. Convert PowerShell-style $env:VARIABLE to %VARIABLE% and then expand using .NET method
        # This resolves the "Cannot find drive '$env'" issue.
        # Regex to find $env:VARNAME (e.g., $env:TEMP, $env:USERPROFILE)
        $envVarRegex = '\$env:([a-zA-Z_][a-zA-Z0-9_]*)'
        $processedBaseDir = [regex]::Replace($processedBaseDir, $envVarRegex, '`%$1`%') # Replace $env:VAR with %VAR%

        # Now, expand environment variables using the .NET method which expects %VAR% syntax
        $baseDir = [Environment]::ExpandEnvironmentVariables($processedBaseDir)
        
        # Perform final validation on the resolved BaseDir path.
        if (-not ($baseDir -is [string] -and $baseDir -notmatch '^\s*$')) {
            throw "Resolved BaseDir is empty or not a valid string after all expansions: '$baseDir'."
        }
        Write-Log "Base directory resolved to: '$baseDir'"
        Write-Host "Resolved Base Directory: '$baseDir'" # Debug output for user
    }
    catch {
        throw "Failed to resolve BaseDir from config: $($_.Exception.Message)"
    }

    # Set up the full paths for logs, reports, backups, and state file based on the resolved BaseDir.
    # IMPORTANT: Update the global $script:logDir variable here so subsequent logs go to the correct location.
    $script:logDir = "$baseDir\Logs" 
    $reportDir = "$baseDir\Reports"
    $backupDir = "$baseDir\Backups"
    $stateFile = "$baseDir\State.json"

    # Create all necessary directories if they do not already exist.
    $dirsToCreate = @($script:logDir, $reportDir, $backupDir) # Use $script:logDir for consistency.
    foreach ($dir in $dirsToCreate) {
        try {
            if (!(Test-Path $dir)) {
                New-Item -ItemType Directory -Path $dir -Force -ErrorAction Stop | Out-Null
                Write-Log "Created directory: '$dir'"
            } else {
                Write-Log "Directory already exists: '$dir'" -Level "DEBUG"
            }
        }
        catch {
            throw "Failed to create directory '$dir': $($_.Exception.Message)"
        }
    }

    # If initial log entries were written to a temporary file, copy them to the main log file.
    if ($initialLogFileUsed -and (Test-Path -Path $tempLogFilePath -ErrorAction SilentlyContinue)) {
        try {
            Add-Content -Path "$($script:logDir)\Main.log" -Value (Get-Content $tempLogFilePath) -ErrorAction SilentlyContinue
            Remove-Item $tempLogFilePath -ErrorAction SilentlyContinue
            Write-Log "Copied initial log entries from temp file to main log."
        }
        catch {
            Write-Log "Failed to copy initial log entries: $($_.Exception.Message)" -Level "WARNING"
        }
    }

}
catch {
    # Handle any fatal errors during configuration loading or directory setup.
    Write-Log "Error loading configuration or setting up directories: $($_.Exception.Message)" -Level "FATAL"
    Write-Host "$COLOR_RED[FATAL]: Configuration or directory setup failed. $($_.Exception.Message)$COLOR_RESET"
    # Attempt to clean up the lock file even on fatal errors before exiting.
    if (Test-Path $lockFile) { Remove-Item $lockFile -ErrorAction SilentlyContinue }
    exit 1 # Exit the script with an error code.
}

Write-Host "$COLOR_GREENInitialization complete.$COLOR_RESET"

# Step 4: Main processing logic for your script's operations.
Write-Log "Starting main processing phase."

# Example: Using the Invoke-Ollama function to get a summary.
$ollamaPrompt = "Summarize the key benefits of using PowerShell for automation."
$ollamaSummary = Invoke-Ollama -Prompt $ollamaPrompt

if ($ollamaSummary) {
    Write-Host "$COLOR_CYANOllama Summary:$COLOR_RESET`n$ollamaSummary"
    Write-Log "Successfully got Ollama summary."
} else {
    Write-Host "$COLOR_REDFailed to get Ollama summary.$COLOR_RESET"
    Write-Log "Failed to get Ollama summary." -Level "ERROR"
}

# This is where your core script logic for different phases would be implemented.
# You would typically define separate functions for each phase (e.g., Invoke-Phase1, Invoke-Phase2)
# and then call them conditionally based on the parameters ($selectedPhase, $automated).

# Example placeholder for phase execution flow:
if ($selectedPhase) {
    Write-Host "Executing only $selectedPhase..."
    Write-Log "Executing only $selectedPhase."
    switch ($selectedPhase) {
        "Phase1" { Write-Host "Executing Phase 1 logic (Placeholder)..." ; Start-Sleep -Milliseconds 200 ; $script:completedPhases += "Phase1" }
        "Phase2" { Write-Host "Executing Phase 2 logic (Placeholder)..." ; Start-Sleep -Milliseconds 200 ; $script:completedPhases += "Phase2" }
        "Phase3" { Write-Host "Executing Phase 3 logic (Placeholder)..." ; Start-Sleep -Milliseconds 200 ; $script:completedPhases += "Phase3" }
        "Phase4" { Write-Host "Executing Phase 4 logic (Placeholder)..." ; Start-Sleep -Milliseconds 200 ; $script:completedPhases += "Phase4" }
        "Phase5" { Write-Host "Executing Phase 5 logic (Placeholder)..." ; Start-Sleep -Milliseconds 200 ; $script:completedPhases += "Phase5" }
        "Phase6" { Write-Host "Executing Phase 6 logic (Placeholder)..." ; Start-Sleep -Milliseconds 200 ; $script:completedPhases += "Phase6" }
        "Phase7" { Write-Host "Executing Phase 7 logic (Placeholder)..." ; Start-Sleep -Milliseconds 200 ; $script:completedPhases += "Phase7" }
        "Phase8" { 
            Write-Host "$COLOR_CYANSelected Phase 8: Running all integrated modules for testing/orchestration.$COLOR_RESET"
            Invoke-AllCoreModules -Config $Config -BaseDir $baseDir
        }
        default { Write-Log "Unknown phase selected: $selectedPhase" -Level "WARNING" }
    }
} elseif ($automated) {
    Write-Host "Running in automated mode, executing all core modules."
    Write-Log "Running in automated mode, executing all core modules."
    Invoke-AllCoreModules -Config $Config -BaseDir $baseDir
} else {
    Write-Host "Running interactively. No specific phase selected or automated mode. You can use -Phase 8 to run all integrated modules."
    Write-Log "Running interactively. No specific phase selected or automated mode."
    # Optional: You could add interactive prompts or a menu for manual phase selection here.
}

# Example of how you might update $completedPhases and $phaseReports based on phase execution.
# $completedPhases += "PhaseX"
# $phaseReports["PhaseX"] = "Report content for PhaseX"

Write-Log "Main processing phase completed."

#endregion

#region --- Script Finalization and Cleanup ---

# This section executes at the very end of the script, performing final tasks and cleanup.

$endTime = Get-Date # Record the script end time.
$duration = New-TimeSpan -Start $startTime -End $endTime # Calculate the total execution duration.
Write-Log "Script finished. Total duration: $($duration.TotalSeconds) seconds."

Write-Host "$COLOR_GREENScript execution finished.$COLOR_RESET"
Write-Host "$COLOR_GREENTotal duration: $($duration.ToString('g'))$COLOR_RESET" # Displays duration in a general, short format.

# Clean up the lock file to allow future runs of the script.
try {
    if (Test-Path $lockFile) {
        Remove-Item $lockFile -ErrorAction Stop # -ErrorAction Stop ensures we know if removal failed.
        Write-Log "Lock file '$lockFile' removed."
    }
}
catch {
    # Log and display an error if the lock file cannot be removed.
    Write-Log "Failed to remove lock file '$lockFile'. $($_.Exception.Message)" -Level "ERROR"
    Write-Host "$COLOR_RED[ERROR]: Failed to remove lock file '$lockFile'. Please remove it manually if necessary.$COLOR_RESET"
}

#endregion
